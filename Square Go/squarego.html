<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Square Go</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation;
        }
        .board {
            display: grid;
            /* The background color will show through the gaps, creating the grid lines */
            background-color: #374151; /* gray-700 */
            /* Add a gap to create the grid lines */
            gap: 2px;
            /* Green border as requested */
            border: 6px solid #15803d; /* green-700 */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 4px; /* Padding to make the border look good */
            border-radius: 0.5rem;
        }
        .board-cell {
            position: relative;
            width: 100%;
            padding-bottom: 100%; /* Creates a square aspect ratio */
            background-color: #ca8a04; /* yellow-600 - The color of an empty tile */
            cursor: pointer;
        }
        /* Removed the ::before and ::after pseudo-elements that created the old grid lines */

        .stone {
            position: absolute;
            /* Fill the entire cell */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Make them squares */
            border-radius: 0; 
            transform: none;
            z-index: 2;
            transition: all 0.1s ease-in-out;
        }
        .stone.black { background-color: #1f2937; /* gray-800 */ box-shadow: inset 0 2px 4px rgba(0,0,0,0.5); }
        .stone.white { background-color: #f9fafb; /* gray-50 */ box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); }

        .hover-stone {
            position: absolute;
            /* Fill the entire cell */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Make them squares */
            border-radius: 0;
            transform: none;
            z-index: 3;
            opacity: 0.5;
            pointer-events: none;
        }
        .territory-black { background-color: rgba(31, 41, 55, 0.5); }
        .territory-white { background-color: rgba(249, 250, 251, 0.5); }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto">
        <h1 class="text-4xl font-bold text-center text-gray-700 mb-4">Square Go</h1>

        <!-- Controls -->
        <div class="bg-white p-4 rounded-lg shadow-md mb-4 flex flex-wrap items-center justify-center gap-4">
            <div class="flex items-center gap-2">
                <label for="board-size" class="font-medium text-gray-600">Board Size:</label>
                <select id="board-size" class="p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="9">9x9</option>
                    <option value="13">13x13</option>
                    <option value="19" selected>19x19</option>
                </select>
            </div>
            <button id="pass-btn" class="px-4 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-opacity-75">Pass Turn</button>
            <button id="new-game-btn" class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">New Game</button>
        </div>

        <!-- Game Info -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4 text-center">
            <div class="bg-white p-4 rounded-lg shadow-md">
                <h2 class="text-lg font-bold">Black</h2>
                <p class="text-2xl" id="black-score">Score: 0</p>
                <p class="text-sm text-gray-500">Captures: <span id="black-captures">0</span></p>
            </div>
            <div id="turn-indicator-parent" class="bg-white p-4 rounded-lg shadow-md flex flex-col items-center justify-center">
                 <h2 class="text-lg font-bold">Current Turn</h2>
                 <div id="turn-indicator" class="w-10 h-10 mt-1 stone black"></div>
            </div>
            <div class="bg-white p-4 rounded-lg shadow-md">
                <h2 class="text-lg font-bold">White</h2>
                <p class="text-2xl" id="white-score">Score: 0</p>
                <p class="text-sm text-gray-500">Captures: <span id="white-captures">0</span></p>
            </div>
        </div>
        
        <!-- Message Area -->
        <div id="message-area" class="text-center text-red-600 font-semibold h-6 mb-2"></div>

        <!-- Game Board -->
        <div id="game-board" class="board"></div>
    </div>

    <script>
        const boardElement = document.getElementById('game-board');
        const sizeSelector = document.getElementById('board-size');
        const passBtn = document.getElementById('pass-btn');
        const newGameBtn = document.getElementById('new-game-btn');
        const turnIndicator = document.getElementById('turn-indicator');
        const blackScoreEl = document.getElementById('black-score');
        const whiteScoreEl = document.getElementById('white-score');
        const blackCapturesEl = document.getElementById('black-captures');
        const whiteCapturesEl = document.getElementById('white-captures');
        const messageArea = document.getElementById('message-area');

        let boardSize = 19;
        let boardState = [];
        let history = []; // For Superko rule
        let currentPlayer = 'black';
        let captures = { black: 0, white: 0 };
        let consecutivePasses = 0;
        let gameOver = false;

        // --- Game Initialization ---
        function initGame() {
            boardSize = parseInt(sizeSelector.value);
            boardState = Array(boardSize * boardSize).fill(null);
            history = [];
            currentPlayer = 'black';
            captures = { black: 0, white: 0 };
            consecutivePasses = 0;
            gameOver = false;
            passBtn.disabled = false;
            
            createBoard();
            updateTurnIndicator();
            updateScores();
            clearMessage();
        }

        function createBoard() {
            boardElement.innerHTML = '';
            boardElement.style.gridTemplateColumns = ;
            
            for (let i = 0; i < boardSize * boardSize; i++) {
                const cell = document.createElement('div');
                cell.classList.add('board-cell');
                cell.dataset.index = i;
                
                // Add event listeners
                cell.addEventListener('mouseenter', () => handleMouseEnter(i));
                cell.addEventListener('mouseleave', () => handleMouseLeave(i));
                cell.addEventListener('click', () => handleCellClick(i));

                boardElement.appendChild(cell);
            }
        }

        // --- UI Updates ---
        function updateTurnIndicator() {
            turnIndicator.className = ;
        }
        
        function updateScores() {
            blackCapturesEl.textContent = captures.black;
            whiteCapturesEl.textContent = captures.white;
            blackScoreEl.textContent = ;
            whiteScoreEl.textContent = ;
        }

        function drawBoard() {
            for (let i = 0; i < boardSize * boardSize; i++) {
                const cell = boardElement.querySelector();
                // Clear existing stone if any
                const existingStone = cell.querySelector('.stone');
                if (existingStone) {
                    existingStone.remove();
                }

                // Draw new stone if it exists in the state
                if (boardState[i]) {
                    const stone = document.createElement('div');
                    stone.classList.add('stone', boardState[i]);
                    cell.appendChild(stone);
                }
            }
        }

        function showMessage(msg) {
            messageArea.textContent = msg;
        }

        function clearMessage() {
            messageArea.textContent = '';
        }

        // --- Event Handlers ---
        function handleMouseEnter(index) {
            if (gameOver || boardState[index]) return;
            const cell = boardElement.querySelector();
            const hoverStone = document.createElement('div');
            hoverStone.classList.add('hover-stone', currentPlayer);
            cell.appendChild(hoverStone);
        }

        function handleMouseLeave(index) {
            if (gameOver) return;
            const cell = boardElement.querySelector();
            const hoverStone = cell.querySelector('.hover-stone');
            if (hoverStone) {
                hoverStone.remove();
            }
        }

        function handleCellClick(index) {
            if (gameOver) return;
            clearMessage();
            
            // Create a temporary board state to test the move
            let tempBoardState = [...boardState];
            
            if (tempBoardState[index] !== null) {
                showMessage("Invalid move! Cell is already occupied.");
                return;
            }
            tempBoardState[index] = currentPlayer;

            // Handle captures on the temporary board
            const opponent = currentPlayer === 'black' ? 'white' : 'black';
            handleCaptures(opponent, tempBoardState);

            // Check for suicide move on the temporary board
            if (getLiberties(index, tempBoardState).liberties === 0) {
                 showMessage("Suicide move is not allowed.");
                 return;
            }

            // Check for Positional Superko
            const boardString = tempBoardState.join('');
            if (history.includes(boardString)) {
                showMessage("Positional Superko - this board state has occurred before.");
                return;
            }
            
            // If all checks pass, apply the move to the actual board state
            boardState[index] = currentPlayer;
            const capturedStonesCount = handleCaptures(opponent, boardState);
            captures[currentPlayer] += capturedStonesCount;
            history.push(boardState.join(''));

            consecutivePasses = 0;
            drawBoard();
            switchPlayer();
            updateScores();
        }
        
        passBtn.addEventListener('click', () => {
            if (gameOver) return;
            consecutivePasses++;
            if (consecutivePasses >= 2) {
                endGame();
            } else {
                showMessage();
                switchPlayer();
            }
        });

        newGameBtn.addEventListener('click', initGame);
        sizeSelector.addEventListener('change', initGame);

        // --- Game Logic ---
        function switchPlayer() {
            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
            updateTurnIndicator();
        }
        
        function getNeighbors(index) {
            const neighbors = [];
            const x = index % boardSize;
            const y = Math.floor(index / boardSize);

            if (x > 0) neighbors.push(index - 1);
            if (x < boardSize - 1) neighbors.push(index + 1);
            if (y > 0) neighbors.push(index - boardSize);
            if (y < boardSize - 1) neighbors.push(index + boardSize);

            return neighbors;
        }

        function findGroup(startIndex, state) {
            const color = state[startIndex];
            if (!color) return { group: [], liberties: new Set() };

            const group = new Set([startIndex]);
            const liberties = new Set();
            const queue = [startIndex];
            const visited = new Set([startIndex]);

            while (queue.length > 0) {
                const currentIndex = queue.shift();
                
                for (const neighborIndex of getNeighbors(currentIndex)) {
                    if (state[neighborIndex] === null) {
                        liberties.add(neighborIndex);
                    } else if (state[neighborIndex] === color && !visited.has(neighborIndex)) {
                        visited.add(neighborIndex);
                        group.add(neighborIndex);
                        queue.push(neighborIndex);
                    }
                }
            }
            return { group: Array.from(group), liberties: liberties.size };
        }

        function getLiberties(index, state) {
            return findGroup(index, state);
        }

        function handleCaptures(opponentColor, state) {
            let totalCaptured = 0;
            for (let i = 0; i < state.length; i++) {
                if (state[i] === opponentColor) {
                    const { group, liberties } = findGroup(i, state);
                    if (liberties === 0) {
                        totalCaptured += group.length;
                        for (const stoneIndex of group) {
                            state[stoneIndex] = null;
                        }
                    }
                }
            }
            return totalCaptured;
        }
        
        // --- End Game & Scoring ---
        function endGame() {
            gameOver = true;
            showMessage("Game Over! Calculating score...");
            passBtn.disabled = true;

            const territory = calculateTerritory();
            const territoryScores = { black: 0, white: 0 };

            for(let i = 0; i < boardSize * boardSize; i++) {
                if (territory[i] === 'black') territoryScores.black++;
                if (territory[i] === 'white') territoryScores.white++;
            }

            const finalScores = {
                black: captures.black + territoryScores.black,
                white: captures.white + territoryScores.white
            };

            blackScoreEl.textContent = ;
            whiteScoreEl.textContent = ;

            let winnerMessage;
            if (finalScores.black > finalScores.white) {
                winnerMessage = ;
            } else if (finalScores.white > finalScores.black) {
                winnerMessage = ;
            } else {
                winnerMessage = "It's a draw!";
            }
            showMessage(winnerMessage);
            
            // Visually show territory
            for (let i = 0; i < boardSize * boardSize; i++) {
                if (territory[i]) {
                    const cell = boardElement.querySelector();
                    const territoryMarker = document.createElement('div');
                    territoryMarker.classList.add();
                    territoryMarker.style.position = 'absolute';
                    territoryMarker.style.width = '50%';
                    territoryMarker.style.height = '50%';
                    territoryMarker.style.top = '25%';
                    territoryMarker.style.left = '25%';
                    // Make the territory marker a square
                    territoryMarker.style.borderRadius = '0'; 
                    cell.appendChild(territoryMarker);
                }
            }
        }

        function calculateTerritory() {
            const territory = Array(boardSize * boardSize).fill(null);
            const visited = new Set();

            for (let i = 0; i < boardSize * boardSize; i++) {
                if (boardState[i] === null && !visited.has(i)) {
                    const queue = [i];
                    const region = new Set([i]);
                    visited.add(i);
                    let touchesBlack = false;
                    let touchesWhite = false;

                    while (queue.length > 0) {
                        const current = queue.shift();
                        
                        for (const neighbor of getNeighbors(current)) {
                            if (boardState[neighbor] === 'black') {
                                touchesBlack = true;
                            } else if (boardState[neighbor] === 'white') {
                                touchesWhite = true;
                            } else if (!visited.has(neighbor)) {
                                visited.add(neighbor);
                                region.add(neighbor);
                                queue.push(neighbor);
                            }
                        }
                    }

                    if (touchesBlack && !touchesWhite) {
                        region.forEach(idx => territory[idx] = 'black');
                    } else if (touchesWhite && !touchesBlack) {
                        region.forEach(idx => territory[idx] = 'white');
                    }
                }
            }
            return territory;
        }

        // --- Initial Load ---
        window.onload = initGame;
    </script>
</body>
</html>

